%%
boolean "BOOLEAN"
byte "BYTE"
short "SHORT"
int "INT"
long "LONG"
char "CHAR"
float "FLOAT"
double "DOUBLE"
\[ "LBRACK"
\] "RBRACK"
\.\.\. "ELLIPSIS"
\. "DOT"
; "SEMICOLON"
\* "MULT"
, "COMMA"
\{ "LBRACE"
\} "RBRACE"
= "EQ"
\( "LPAREN"
\) "RPAREN"
: "COLON"
@ "AT"
package "PACKAGE"
import "IMPORT"
public "PUBLIC"
protected "PROTECTED"
private "PRIVATE"
static "STATIC"
abstract "ABSTRACT"
final "FINAL"
native "NATIVE"
synchronized "SYNCHRONIZED"
transient "TRANSIENT"
volatile "VOLATILE"
strictfp "STRICTFP"
class "CLASS"
enum "ENUM"
extends "EXTENDS"
implements "IMPLEMENTS"
void "VOID"
throws "THROWS"
this "THIS"
super "SUPER"
interface "INTERFACE"
if "IF"
else "ELSE"
switch "SWITCH"
case "CASE"
default "DEFAULT"
do "DO"
while "WHILE"
for "FOR"
break "BREAK"
continue "CONTINUE"
return "RETURN"
throw "THROW"
try "TRY"
catch "CATCH"
finally "FINALLY"
assert "ASSERT"
new "NEW"
\+\+ "PLUSPLUS"
-- "MINUSMINUS"
\+ "PLUS"
- "MINUS"
~ "COMP"
! "NOT"
/ "DIV"
% "MOD"
<< "LSHIFT"
>> "RSHIFT"
>>> "URSHIFT"
<<= "LSHIFTEQ"
>>= "RSHIFTEQ"
>>>= "URSHIFTEQ"
<= "LTEQ"
>= "GTEQ"
< "LT"
> "GT"
instanceof "INSTANCEOF"
== "EQEQ"
!= "NOTEQ"
&& "ANDAND"
\|\| "OROR"
& "AND"
\^ "XOR"
\| "OR"
\? "QUESTION"
\*= "MULTEQ"
/= "DIVEQ"
%= "MODEQ"
\+= "PLUSEQ"
-= "MINUSEQ"
&= "ANDEQ"
\^= "XOREQ"
\|= "OREQ"

[0-9]+\.[0-9]*([eE][+-]?[0-9]+)?[fFdD]?|\.[0-9]+([eE][+-]?[0-9]+)?[fFdD]?|[0-9]+[eE][+-]?[0-9]+[fFdD]?|[0-9]+[fFdD]|0[xX][0-9A-Fa-f]+(\.[0-9A-Fa-f]*)?[pP][+-]?[0-9]+[fFdD]? "FLOATING_POINT_LITERAL"
(0_[0-7]+|[0-9][0-9_]+[0-9]|0[bB][01]+|0[xX][0-9A-Fa-f]+|[0-9]+)[lL]? "INTEGER_LITERAL"
(true|false) "BOOLEAN_LITERAL"
null "NULL_LITERAL"
[\w_][\w_0-9]* "IDENTIFIER"

'([^\t\n\r\f\\'\\]|\\[tnfr'"\\]|\\[0-3][0-7][0-7]|\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])' "CHARACTER_LITERAL"
"(?:\\\\|\\"|[^"\n])*" "STRING_LITERAL"
/[*].*?[*]/ ;

//[^\n]*?$ ;
[ \t\n\r]+ ;
