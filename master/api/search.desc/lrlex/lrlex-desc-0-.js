searchState.loadedDescShard("lrlex", 0, "<code>lrlex</code> is a partial replacement for <code>lex</code> / <code>flex</code>. It takes in …\nAn interface to the result of CTLexerBuilder::build().\nA <code>CTLexerBuilder</code> allows one to specify the criteria for …\nExports all token IDs used by a parser as a separate Rust …\nlrlex’s standard lexeme struct, provided as a …\nlrlex’s standard LexerTypes <code>struct</code>, provided as a …\nContains the error value\nA Lexing error.\nAn <code>LRNonStreamingLexer</code> holds a reference to a string and …\nThis struct represents, in essence, a .l file in memory. …\nAny error from the Lex parser returns an instance of this …\nThe various different possible Lex parser errors.\nMethods which all lexer definitions must implement.\nContains the success value\nModule-level visibility only.\n<code>pub</code>\n<code>pub(crate)</code>\n<code>pub(in {arg})</code>\n<code>pub(self)</code>\n<code>pub(super)</code>\nSpecifies the Rust Edition that will be emitted during …\nSpecify the visibility of the module generated by …\nControl whether the builder will add <code>#[allow(dead_code)]</code> …\nIf passed false, tokens used in the grammar but not …\nIf passed false, tokens defined in the lexer but not used …\nEnables <code>// comment</code> style parsing according to …\nStatically compile the <code>.l</code> file specified by …\nBuild the token map module.\nSets the <code>regex::RegexBuilder</code> option of the same name. …\nCreate a Rust module named <code>mod_name</code> that can be imported …\nSets the <code>regex::RegexBuilder</code> option of the same name. …\nSets the <code>regex::RegexBuilder</code> option of the same name. The …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInstantiate a lexer from a string (e.g. representing a <code>.l</code> …\nGiven a <code>.l</code> file in an <code>&amp;str</code>, returns a …\nGet the <code>Rule</code> at index <code>idx</code>.\nGet the <code>Rule</code> instance associated with a particular lexeme …\nGet the <code>Rule</code> instance associated with a particular name.\nSets the <code>regex::RegexBuilder</code> option of the same name. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator over all rules in this AST.\nReturns an iterator over all start states in this AST.\nReturn an LRNonStreamingLexer for the <code>String</code> <code>s</code> that will …\nSet the input lexer path to a file relative to this project…\nSet the input lexer path to <code>inp</code>. If specified, you must …\nSet the type of lexer to be generated to <code>lexerkind</code>.\nReturns the state, if there was one, that the lexer was in …\nA convenience macro for including statically compiled <code>.l</code> …\nAn optional convenience function to make it easier to …\nSet the generated module name to <code>mod_name</code>. If no module …\nSets the <code>regex::RegexBuilder</code> option of the same name. The …\nSets the <code>regex::RegexBuilder</code> option of the same name. …\nCreate a new CTLexerBuilder.\nCreate a new <code>LRNonStreamingLexer</code> that read in: the input <code>s</code>…\nCreate a new token map builder.\nConstruct a new LRLex error covering <code>span</code>.\nCreate a new CTLexerBuilder.\nConstruct a new LRLex error covering <code>span</code> for <code>lexing_state</code>.\nUses the <code>lex_flags</code> passed in ignoring any settings in the …\nSets the <code>regex::RegexBuilder</code> option of the same name. The …\nSet the output lexer path to <code>outp</code>. Note that there are no …\nEnables posix lex compatible escape sequences according to …\nStatically compile the <code>.l</code> file <code>inp</code> into Rust, placing the …\nGiven the filename <code>a/b.l</code> as input, statically compile the …\nSet a token rename map.\nSet this lexer builder’s map of rule IDs to <code>rule_ids_map</code>…\nSets the rust edition to be used for generated code. …\nSet the id attribute on rules to the corresponding value …\nIf set to true, CTParserBuilder::build will print warnings …\nSets the <code>regex::RegexBuilder</code> option of the same name. …\nSets the <code>regex::RegexBuilder</code> option of the same name. …\nSets the <code>regex::RegexBuilder</code> option of the same name. …\nA module for lifting restrictions on visibility by …\nSet the visibility of the generated module to <code>vis</code>. …\nIf set to true, CTLexerBuilder::build will return an error …\nAn value that acts as a key to inform callers that they are\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")