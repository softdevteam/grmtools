searchState.loadedDescShard("lrpar", 0, "<code>lrpar</code> provides a Yacc-compatible parser (where grammars …\nThe CPCT+ algorithm from Diekmann/Tratt “Don’t Panic! …\nAn interface to the result of CTParserBuilder::build().\nA <code>CTParserBuilder</code> allows one to specify the criteria for …\nDelete a symbol.\nInsert a <code>Symbol::Token</code>.\nA lexing error.\nA lexing or parsing error. Although the two are quite …\nA lexeme represents a segment of the user’s input that …\nThe base trait which all lexers which want to interact …\nA <code>NonStreamingLexer</code> is one that takes input in one go, and …\nDon’t use error recovery: return as soon as the first …\nRecords a single parse error.\nAfter a parse error is encountered, the parser attempts to …\nModule-level visibility only.\n<code>pub</code>\n<code>pub(crate)</code>\n<code>pub(in {arg})</code>\n<code>pub(self)</code>\n<code>pub(super)</code>\nA run-time parser builder.\nWhat recovery algorithm should be used when a syntax error …\nSpecifies the Rust Edition that will be emitted during …\nShift a symbol.\nA <code>Span</code> records what portion of the user’s input …\nSpecify the visibility of the module generated by <code>CTBuilder</code>…\nThe action which implements …\nStatically compile the Yacc file specified by …\nIf there are any conflicts in the grammar, return a tuple …\nByte offset of the end of the span.\nIf set to true, CTParserBuilder::build will return an …\nReturns <code>true</code> if this lexeme is “faulty” i.e. is the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSet the input grammar path to a file relative to this …\nSet the input grammar path to <code>inp</code>. If specified, you must …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if this <code>Span</code> covers 0 bytes, or <code>false</code> …\nIterate over all the lexemes in this lexer. Note that:\nLength in bytes of the span.\nReturn the lexeme where this error was detected.\nReturn <code>((start line, start column), (end line, end column))</code>…\nA convenience macro for including statically compiled <code>.y</code> …\nSet the generated module name to <code>mod_name</code>. If no module …\nCreate a new lexeme with ID <code>tok_id</code>, a starting position in …\nCreate a new <code>CTParserBuilder</code>.\nCreate a new run-time parser from a <code>YaccGrammar</code>, and a …\nCreate a new span starting at byte <code>start</code> and ending at …\nCreate a new faulty lexeme with ID <code>tok_id</code> and a starting …\nSet the output grammar path to <code>outp</code>. Note that there are …\nParse input, execute actions, and return the associated …\nParse input, and (if possible) return a generic parse …\nParse input, and (if possible) return a generic parse …\nParse input, returning any errors found. See the arguments …\nReturn a pretty-printed version of this node.\nA pretty-printer of a lexer/parser error. This isn’t …\nStatically compile the Yacc file <code>inp</code> into Rust, placing …\nGiven the filename <code>a/b.y</code> as input, statically compile the …\nSet the recoverer for this parser to <code>rk</code>. Defaults to …\nSet the recoverer for this parser to <code>rk</code>.\nReturns <code>true</code> if this compile-time parser was regenerated …\nReturn the repairs found that would fix this error. Note …\nSets the rust edition to be used for generated code. …\nIf set to true, CTParserBuilder::build will print warnings …\nObtain this <code>Lexeme</code>’s Span.\nReturn the span associated with this error.\nReturn the lines containing the input at <code>span</code> (including …\nReturn the user input associated with a Span.\nByte offset of the start of the span.\nReturn the state table index where this error was detected.\nThe token ID.\nReturns a HashMap from lexeme string types to numeric …\nA module for lifting restrictions on visibility by …\nSet the visibility of the generated module to <code>vis</code>. …\nIf set to true, CTParserBuilder::build will return an …\nSet the <code>YaccKind</code> for this parser to <code>ak</code>.\nAn value that acts as a key to inform callers that they are\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")