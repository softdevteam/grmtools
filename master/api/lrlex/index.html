<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`lrlex` is a partial replacement for `lex` / `flex`. It takes in a `.l` file and statically compiles it to Rust code. The resulting LRNonStreamingLexerDef can then be given an input string, from which it instantiates an LRNonStreamingLexer. This provides an iterator which can produce the sequence of lrpar::Lexemes for that input, as well as answer basic queries about cfgrammar::Spans (e.g. extracting substrings, calculating line and column numbers)."><title>lrlex - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="lrlex" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../lrlex/index.html">lrlex</a><span class="version">0.14.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>lrlex</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/lrlex/mod.rs.html#1-291">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>lrlex</code> is a partial replacement for <a href="http://dinosaur.compilertools.net/lex/index.html"><code>lex</code></a>
/ <a href="https://westes.github.io/flex/manual/"><code>flex</code></a>. It takes in a <code>.l</code> file and statically
compiles it to Rust code. The resulting <a href="struct.LRNonStreamingLexerDef.html" title="struct lrlex::LRNonStreamingLexerDef">LRNonStreamingLexerDef</a> can then be given an input
string, from which it instantiates an <a href="struct.LRNonStreamingLexer.html" title="struct lrlex::LRNonStreamingLexer">LRNonStreamingLexer</a>. This provides an iterator which
can produce the sequence of <a href="../lrpar/lex_api/trait.Lexeme.html" title="trait lrpar::lex_api::Lexeme">lrpar::Lexeme</a>s for that input, as well as answer basic queries
about <a href="../cfgrammar/span/struct.Span.html" title="struct cfgrammar::span::Span">cfgrammar::Span</a>s (e.g. extracting substrings, calculating line and column numbers).</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="unstable_api/index.html" title="mod lrlex::unstable_api">unstable_<wbr>api</a></dt><dd>A module for lifting restrictions on visibility by enabling unstable features.</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.lrlex_mod.html" title="macro lrlex::lrlex_mod">lrlex_<wbr>mod</a></dt><dd>A convenience macro for including statically compiled <code>.l</code> files. A file <code>src/a/b/c.l</code>
processed by <a href="struct.CTLexerBuilder.html#method.lexer_in_src_dir" title="method lrlex::CTLexerBuilder::lexer_in_src_dir">CTLexerBuilder::lexer_in_src_dir</a> can then be used in a crate with
<code>lrlex_mod!("a/b/c.l")</code>.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.CTLexer.html" title="struct lrlex::CTLexer">CTLexer</a></dt><dd>An interface to the result of <a href="struct.CTLexerBuilder.html#method.build" title="method lrlex::CTLexerBuilder::build">CTLexerBuilder::build()</a>.</dd><dt><a class="struct" href="struct.CTLexerBuilder.html" title="struct lrlex::CTLexerBuilder">CTLexer<wbr>Builder</a></dt><dd>A <code>CTLexerBuilder</code> allows one to specify the criteria for building a statically generated
lexer.</dd><dt><a class="struct" href="struct.CTTokenMapBuilder.html" title="struct lrlex::CTTokenMapBuilder">CTToken<wbr>MapBuilder</a></dt><dd>Exports all token IDs used by a parser as a separate Rust module.</dd><dt><a class="struct" href="struct.DefaultLexeme.html" title="struct lrlex::DefaultLexeme">Default<wbr>Lexeme</a></dt><dd>lrlex’s standard lexeme struct, provided as a convenience.</dd><dt><a class="struct" href="struct.DefaultLexerTypes.html" title="struct lrlex::DefaultLexerTypes">Default<wbr>Lexer<wbr>Types</a></dt><dd>lrlex’s standard <a href="../lrpar/lex_api/trait.LexerTypes.html" title="trait lrpar::lex_api::LexerTypes">LexerTypes</a> <code>struct</code>, provided as a convenience.</dd><dt><a class="struct" href="struct.LRLexError.html" title="struct lrlex::LRLexError">LRLex<wbr>Error</a></dt><dd>A Lexing error.</dd><dt><a class="struct" href="struct.LRNonStreamingLexer.html" title="struct lrlex::LRNonStreamingLexer">LRNon<wbr>Streaming<wbr>Lexer</a></dt><dd>An <code>LRNonStreamingLexer</code> holds a reference to a string and can lex it into <a href="../lrpar/lex_api/trait.Lexeme.html" title="trait lrpar::lex_api::Lexeme">lrpar::Lexeme</a>s.
Although the struct is tied to a single string, no guarantees are made about whether the
lexemes are cached or not.</dd><dt><a class="struct" href="struct.LRNonStreamingLexerDef.html" title="struct lrlex::LRNonStreamingLexerDef">LRNon<wbr>Streaming<wbr>Lexer<wbr>Def</a></dt><dd>This struct represents, in essence, a .l file in memory. From it one can produce an
<a href="struct.LRNonStreamingLexer.html" title="struct lrlex::LRNonStreamingLexer">LRNonStreamingLexer</a> which actually lexes inputs.</dd><dt><a class="struct" href="struct.LexBuildError.html" title="struct lrlex::LexBuildError">LexBuild<wbr>Error</a></dt><dd>Any error from the Lex parser returns an instance of this struct.</dd><dt><a class="struct" href="struct.StartStateId.html" title="struct lrlex::StartStateId">Start<wbr>State<wbr>Id</a></dt></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.LexErrorKind.html" title="enum lrlex::LexErrorKind">LexError<wbr>Kind</a></dt><dd>The various different possible Lex parser errors.</dd><dt><a class="enum" href="enum.LexerKind.html" title="enum lrlex::LexerKind">Lexer<wbr>Kind</a></dt><dt><a class="enum" href="enum.RustEdition.html" title="enum lrlex::RustEdition">Rust<wbr>Edition</a></dt><dd>Specifies the <a href="https://doc.rust-lang.org/edition-guide/rust-2021/index.html">Rust Edition</a> that will be emitted during code generation.</dd><dt><a class="enum" href="enum.Visibility.html" title="enum lrlex::Visibility">Visibility</a></dt><dd>Specify the visibility of the module generated by <a href="struct.CTLexerBuilder.html" title="struct lrlex::CTLexerBuilder">CTLexerBuilder</a>.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.LexerDef.html" title="trait lrlex::LexerDef">Lexer<wbr>Def</a></dt><dd>Methods which all lexer definitions must implement.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.ct_token_map.html" title="fn lrlex::ct_token_map">ct_<wbr>token_<wbr>map</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Create a Rust module named <code>mod_name</code> that can be imported with
<a href="macro.lrlex_mod.html" title="macro lrlex::lrlex_mod"><code>lrlex_mod!(mod_name)</code></a>.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.LexBuildResult.html" title="type lrlex::LexBuildResult">LexBuild<wbr>Result</a></dt><dt><a class="type" href="type.NonStreamingLexerDef.html" title="type lrlex::NonStreamingLexerDef">NonStreaming<wbr>Lexer<wbr>Def</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt></dl></section></div></main></body></html>